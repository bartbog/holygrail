\chapter{Een grammatica voor logigrammen}
\label{ch:grammatica}

In dit hoofdstuk overlopen we de gebruikte grammaticale categorieën en de grammaticale regels die erbij horen, samen met hun semantiek. We beginnen bij de categorieën die bestaan uit lexicale categorieën en werken naar boven toe richting de categorie van een zin. We gebruiken de DCG-notatie uit hoofdstuk~\ref{sec:DCG}. De feature \texttt{sem} staat voor de semantiek van een woordgroep.

\paragraph{}De grammatica is opgesteld vertrekkend van code van Blackburn en Bos \cite{Blackburn2006} en op basis van de eerste 10 logigrammen uit Puzzle Baron's Logic Puzzles Volume 3 \cite{logigrammen}. De grammatica regels van Blackburn en Bos die niet van toepassing zijn voor logigrammen zijn verwijderd.

\section{Lexicale categorieën}
\subsection{Een mapping naar het lexicon}
\label{sec:lexgram}
De meeste van de grammaticale categorieën die de link vormen met het lexicon volgend de structuur uit grammatica~\ref{dcg:lexcat}. Hierbij staat \textit{cat} voor de categorie in kwestie. De grammaticale regel bestaat uit het opzoeken van een woord in het lexicon (m.b.v. de functie \texttt{lexEntry}). Hierbij kijken we niet alleen naar de lexicale categorie maar ook naar andere features zoals getal; controleren dat het woord uit het lexicon het volgende woord is in de zin (lijn 3); en tenslotte het opzoeken van de betekenis van het woord (m.b.v. de functie \texttt{semLex}). Dit resulteert in de formules van hoofdstuk~\ref{ch:lexicon}.

\begin{dcg}{Een grammaticale regel voor een lexicale categorie \textit{cat}}{dcg:lexcat}
cat([feature1:Feature1, type:Type, sem:Sem]) -->
  { lexEntry(cat, [feature1:Feature1, type:Type, syntax:Word]) },
  Word,
  { semLex(cat, [feature1:Feature1, type:Type, sem:Sem]) }.
\end{dcg}

De categorieën die deze structuur volgen zijn determinatoren (\texttt{det}), hoofdtelwoorden (\texttt{number}), substantieven (\texttt{noun}), voorzetsels (\texttt{prep}), hulpwerkwoorden (\texttt{av}), koppelwerkwoorden (\texttt{cop}) en comparatieven (\texttt{comp}).

\paragraph{}Bijvoorbeeld voor een substantief wordt dit grammatica~\ref{dcg:noun}. Het getal van de grammaticale categorie komt overeen met het getal uit het lexicon. Het symbool dat wordt gebruikt in de betekenis van een woord komt ook uit het lexicon.
\begin{dcg}{De grammaticale regel voor een substantief}{dcg:noun}
noun([num:Num, sem:Sem]) -->
  { lexEntry(noun, [symbol:Sym, num:Num, syntax:Word]) },
  Word,
  { semLex(noun, [symbol:Sym, sem:Sem]) }.
\end{dcg}

\subsection{Eigennaam}
Grammatica~\ref{dcg:pn} geeft de grammaticale regel voor een eigennaam weer. Dit lijkt zeer sterk op de algemene mapping van de grammatica naar het lexicon buiten de optionele ``the''. Deze is nodig omdat in sommige puzzels een bepaalde term zowel met als zonder ``the'' voorkomt. Indien we deze twee verschillende termen allebei apart in het lexicon zouden ingeven, zouden deze worden vertaald naar verschillende symbolen. Dit zouden we graag vermijden \footnote{Een alternatief was om de twee vormen met hetzelfde symbool in het lexicon op te nemen. Dat is equivalent aan onderstaande grammatica}.

\begin{dcg}{De grammaticale regel voor een eigennaam}{dcg:pn}
pn([num:Num, sem:Sem]) -->
  { lexEntry(pn, [symbol:Sym, syntax:Word, num:Num]) },
  optional([the]),
  Word,
  { semLex(pn, [symbol:Sym, sem:Sem]) }.
optional(X) -->
  X.
optional(X) -->
  [].
\end{dcg}

\subsection{Transitief werkwoord}
Er zijn twee grammaticale regels voor een transitief werkwoord (grammatica~\ref{dcg:tv}). Enerzijds is er de standaard mapping van grammatica naar lexicon. De voorzetsels en achtervoegsels uit het lexicon worden als feature meegegeven aan de grammaticale woordgroep. Het getal (\texttt{num}) en de vorm (\texttt{inf}) van de grammaticale woordgroep moet ook overeenkomen met die uit het lexicon.

Anderzijds wordt de combinatie koppelwerkwoord + adjectief ook als een transitief werkwoord gezien. Hierbij is het adjectief het achtervoegsel. De semantiek van deze combinatie is die van het koppelwerkwoord ($\sem{cop_{ap}}$) zoals we die hebben afgeleid in hoofdstuk~\ref{sec:lex-koppelwerkwoord}.
\begin{dcg}{De grammaticale regels voor een transitief werkwoord}{dcg:tv}
tv([inf:Inf, num:Num, positions:Pre-Post, sem:Sem]) -->
  { lexEntry(tv, [symbol:Sym, syntax:Word-Pre-Post, inf:Inf, num:Num]) },
  Word,
  { semLex(tv, [symbol:Sym, sem:Sem]) }.

tv([inf:Inf, num:Num, positions:[]-Post, sem:Sem]) -->
  cop([type:ap, inf:Inf, num:Num, sem:Sem, symbol:Sym]),
  { lexEntry(copAdj, [symbol:Sym, adj:Post]) }.
\end{dcg}

\subsection{Onbepaalde woorden en betrekkelijke voornaamwoorden}
Het is mogelijk om een onbepaald woord te verzwijgen, bijvoorbeeld ``John finished [sometime] before Mia''. Daarom is er een extra regel die zegt dat het woord niet per se hoeft voor te komen in de zin (lijn 5 en 6). Hetzelfde geldt voor betrekkelijke voornaamwoorden.

\begin{dcg}{De grammaticale regels voor onbepaalde woorden en betrekkelijke voornaamwoorden}{dcg:someAndRelpro}
some([sem:Sem]) -->
  { lexEntry(some, [syntax:Word]) },
  Word,
  { semLex(some, [sem:Sem]) }.
some([sem:Sem]) -->
  { semLex(some, [sem:Sem]) }.

relpro([sem:Sem]) -->
  { lexEntry(relpro, [syntax:Word]) },
  Word,
  { semLex(relpro, [sem:Sem]) }.
relpro([sem:Sem]) -->
  { semLex(relpro, [sem:Sem]) }.
\end{dcg}

\subsection{Voegwoord}
Voegwoorden kunnen uit twee delen bestaan: het voegwoord zelf (\texttt{coord}) en een optionele prefix (\texttt{coordPrefix}). De prefix heeft geen vertaling bovenop het voegwoord. Dit zien we ook terug in de eerste grammaticale regel van grammatica~\ref{dcg:coord}. De tweede grammaticale regel stelt ook dat het optioneel is.

De grammaticale regel voor het voegwoord zelf volgt dezelfde structuur als die van sectie~\ref{sec:lexgram}. Een voegwoord kan soms echter weggelaten worden. De grammaticale categorie \texttt{noCoord} stelt een ellips van zo'n voegwoord voor. Er is gekozen voor een aparte categorie omdat een ellips niet overal mag voorkomen.
\begin{dcg}{De grammaticale regels i.v.m. voegwoorden}{dcg:coord}
coordPrefix([type:Type]) -->
  { lexEntry(coordPrefix, [syntax:Word, type:Type]) },
  Word.
coordPrefix([type:_]) -->
  [].

coord([type:Type, sem:Sem]) -->
  { lexEntry(coord, [syntax:Word, type:Type]) },
  Word,
  { semLex(coord, [type:Type, sem:Sem]) }.

noCoord([type:Type, sem:Sem]) -->
  { semLex(coord, [type:Type, sem:Sem]) }.
\end{dcg} 

\section{(Getransformeerde) Substantieven}
Grammatica~\ref{dcg:n} geeft een overzicht van de grammatica regels i.v.m. substantieven en transformaties op die substantieven. De eerste 2 regels zeggen dat een getransformeerd substantief (hiervoor gebruiken we de categorie \texttt{n}) kan bestaan uit een gewoon substantief (\texttt{noun}) al dan niet gevolgd door een transformatie op dat substantief (\texttt{nmod} naar \texttt{noun modifier}). In het geval van een transformatie is de betekenis van het getransformeerde substantief gelijk aan de applicatie van de transformatie op dat van het echte substantief of $\sem{n} = \app{\sem{nmod}}{\sem{noun}}$.

Lijnen 9 t.e.m. 14 van grammatica~\ref{dcg:n} definiëren de mogelijke transformaties: ofwel gaat het om een voorzetselconstituent (\texttt{pp}), ofwel om een betrekkelijke bijzin (\texttt{rc}). In het laatste geval moet het getal van het substantief en het werkwoord uit de bijzin overeenkomen.

\begin{dcg}{De grammaticale regels i.v.m. substantieven}{dcg:n}
n([num:Num, sem:Sem]) -->
  noun([num:Num, sem:Noun]),
  { Sem = Noun }.
n([num:Num, sem:Sem]) -->
  noun([num:Num, sem:Noun]),
  nmod([num:Num, sem:NMod]),
  { Sem = app(NMod, Noun) }.

nmod([num:_, sem:Sem]) -->
  pp([sem:PP]),
  { Sem = PP }.
nmod([num:Num, sem:Sem]) -->
  rc([num:Num, sem:RC]),
  { Sem = RC }.

pp([sem:Sem]) -->
  prep([sem:Prep]),
  np([coord:_, num:_, gap:[], sem:NP]),
  { Sem = app(Prep, NP) }.

rc([num:Num, sem:Sem]) -->
  relpro([sem:RelPro]),
  vp([coord:no, inf:fin, num:Num, gap:[], sem:VP]),
  { Sem = app(RelPro, VP) }.
\end{dcg}

\paragraph{} Lijnen 16 t.e.m. 19 beschrijven de voorzetselconstituent (\texttt{pp}) zoals ``from France''. Deze constituent bestaat namelijk uit een voorzetsel (\texttt{prep}) gevolgd door een nominale constituent (\texttt{np}). De feature \texttt{gap} van de nominale constituent heeft te maken met ellipsen die kunnen voorkomen in die constituent. De lege lijst wilt zeggen dat er geen ellipsen mogelijk zijn.

De betekenis van een voorzetselconstituent bestaat uit een simpele lambda-applicatie ($\sem{pp} = \app{\sem{prep}}{\sem{np}}$).

\paragraph{} Lijnen 21 t.e.m. 24 beschrijven de betrekkelijke bijzin (\texttt{rc}). Zo'n betrekkelijke bijzin bestaat uit een betrekkelijk voornaamwoord (\texttt{relpro}) gevolgd door een verbale constituent. Een voorbeeld van zo'n betrekkelijke bijzin is ``that loves Mary''. De verbale constituent moet simpel zijn (\texttt{coord:no}). Dat wil zeggen dat er geen voegwoorden mogen in voorkomen. Bovendien moet het werkwoord vervoegd zijn (\texttt{inf:fin}) en dus niet in de infinitief voorkomen. Ten slotte moet het getal overeenkomen met dat van het substantief.

De betekenis bestaat opnieuw uit één lambda-applicatie, namelijk $\sem{rc} = \app{\sem{relpro}}{\sem{vp}}$.

\section{Nominale constituent}
Een naamwoordgroep (\texttt{np}) is een woordgroep waarin het naamwoord het belangrijkste woord is en die een entiteit aanduidt. Deze woordgroepen kunnen dienen als onderwerp of als lijdend voorwerp van een werkwoord.

De grammaticale categorie heeft 4 mogelijke features: De feature \texttt{coord} duidt aan of het gaat om een simpele naamgroep (\texttt{coord:no}) of een complexere naamgroep. Zo heeft een naamwoordgroep met een vergelijking de waarde \texttt{comp} voor deze feature. De feature \texttt{num} duidt het getal van de woordgroep aan (enkelvoud \texttt{sg} of meervoud \texttt{pl}). De feature \texttt{gap} geeft aan welke woorden gebruikt zijn in een ellips binnen deze woordgroep. De waarde \texttt{[]} voor deze feature wilt dan weer zeggen dat er geen ellips zit in deze naamwoordgroep. Zoals altijd zit de semantiek in de feature \texttt{sem}.

\paragraph{} Grammatica~\ref{dcg:np1} geeft de eenvoudige naamwoordgroepen weer. De eerste grammaticale regel stelt dat een naamwoordgroep kan bestaan uit een eigennaam (\texttt{pn}) met hetzelfde getal. In dit geval is de semantiek gelijk aan die van de naamwoordgroep.

Daarnaast kan een naamwoordgroep ook bestaan uit een lidwoord (of meer algemeen, een determinator \texttt{det}) en een zelfstandig naamwoord. We gebruiken hier de categorie \texttt{n} i.p.v. \texttt{noun} zodat ook een zelfstandig naamwoord met een bijzin mogelijk is. De semantiek bestaat uit een simpele lambda-applicatie $\sem{np} = \app{\sem{det}}{\sem{n}}$.

Zoals we ook in sectie~\ref{sec:lex-number} besproken hebben, kan een hoofdtelwoord ook aanzien worden als een determinator. We krijgen dus nog een gelijkaardige regel als de vorige maar nu met een hoofdtelwoord i.p.v. een determinator.

Ten slotte kan een getal ook op zichzelf staan zonder zelfstandig naamwoord, bijvoorbeeld als jaartal. De grammaticale regel van lijn 15 t.e.m. 17 dekt dit geval. De semantiek is vergelijkbaar met de vorige grammaticale regel maar er is geen extra restrictie op het getal. Vandaar de lege DRS-structuur in $\sem{np} = \app{\sem{number}}{\lambdaf{x}{\drs{}{}}}$.

\begin{dcg}{De grammaticale regels voor een simpele naamwoordgroep}{dcg:np1}
np([coord:no, num:Num, gap:[], sem:Sem]) -->
  pn([num:Num, sem:PN]),
  { Sem = PN }.

np([coord:no, num:Num, gap:[], sem:Sem]) -->
  det([num:Num, sem:Det]),
  n([num:Num, sem:N]),
  { Sem = app(Det, N) }.

np([coord:no, num:Num, gap:[], sem:Sem]) -->
  number([sem:Number]),
  n([num:Num, sem:N]),
  { Sem = app(Number, N) }.

np([coord:no, num:_, gap:[], sem:Sem]) -->
  number([sem:Number]),
  { Sem = app(A, lam(_, drs([], []))) }.
\end{dcg}

\paragraph{} Grammatica~\ref{dcg:np2} beschrijft twee grammaticale regels met dezelfde semantiek en gelijkaardige structuur. Het gaat om naamwoordgroepen respectievelijk zoals ``the Arkansas native'' en ``John's dog''. Ze bestaan allebei uit een simpele naamwoordgroep (\texttt{np} met \texttt{coord:no}) en een substantief~(\texttt{n}). Er is telkens een link tussen de entiteit van het substantief en dat van de simpele naamwoordgroep maar er is geen kennis over welke link dit juist is. Voor nu laten we het dus nog open. In hoofdstuk~\ref{ch:types} zullen we met behulp van types afleiden welk predicaat nodig is. De entiteit van de substantief is het belangrijkste en is ook de entiteit van de naamwoordgroep als geheel. Als resultaat krijgen we $$\sem{np} = \lambdaf{P}{\appH{\app{\sem{det}}{\sem{n}}}{\lambdaf{x}{\app{\sem{np}}{\lambdaf{y}{\drsMerge{\drs{}{???(x, y)}}{\app{P}{x}}}}}}}$$

Het is een naamwoordgroep en dus een box ($\lambda P$). Daarbinnen pakken we de woordgroep die bestaat uit het lidwoord en het substantief uit naar de entiteit $x$. Vervolgens pakken we de naamdwoordgroep uit naar $y$. Er is een relatie tussen $x$ en $y$ maar deze is voorlopig nog onbekend. Ten slotte stoppen we $x$ in de box van het gehele naamwoordgroep want $x$ is de entiteit waar de naamwoordgroep als geheel naar verwijst.

\paragraph{}Bij de tweede grammaticale regel is er geen expliciet lidwoord aanwezig maar de betekenis hiervan is wel nog steeds nodig om een scope te geven aan het zelfstandig naamwoord. Er wordt dus gebruik gemaakt van dezelfde betekenis alsof er wel een lidwoord had gestaan (lijn 10).

Beiden naamwoordgroepen krijgen de waarde \texttt{np} voor de feature \texttt{coord} naar de extra naamwoordgroep die zich in deze naamwoordgroep bevindt.

\begin{dcg}{De grammaticale regels voor een naamwoordgroep met een onbekende relatie}{dcg:np2}
np([coord:np, num:Num, gap:[], sem:Sem]) -->
  det([num:Num, sem:Det]),
  np([coord:no, num:_, gap:[], sem:NP]),
  n([num:Num, sem:N]),
  { Sem = lam(P, app(app(Det, N), lam(X, app(NP, lam(Y, merge(
    drs([], [rel(_, X, Y)]),
    app(P, X))))))) }.

np([coord:np, num:Num, gap:[], sem:Sem]) -->
  { semLex(det, [num:sg, sem:Det]) },
  np([coord:no, num:_, gap:[], sem:NP]),
  [s],
  n([coord:_, num:Num, sem:N]),
  { Sem = lam(P, app(app(Det, N), lam(X, app(NP, lam(Y, merge(
    drs([], [rel(_, X, Y)]),
    app(P, X))))))) }.
\end{dcg}


\begin{dcg}{De grammaticale regels voor een nominale constituent}{dcg:np}
np([coord:comp, num:Num, gap:G, sem:NP]) -->
  sp([num:Num, gap:[], sem:NP1]),
  comp([sem:Comp]),
  { G = [tv:_ | _] -> Gap = [useTVGap | G] ; Gap = G},
  np([coord:_, num:_, gap:Gap, sem:NP2]),
  { addTypeAttribute(Type, countable) },
  { combine(np:NP, [np:NP1, comp:Comp, np:NP2, vType1:Type, vType2:Type2]) }.
sp([num:_Num, gap:[], sem:NP]) -->
  some([sem:SP]),
  { combine(np:NP, [some:SP]) }.
sp([num:Num, gap:[], sem:NP]) -->
  np([coord:no, num:Num, gap:[], sem:NP]).

np([coord:no, num:sg, gap:[np:NP-Type], sem:NP].

np([coord:no, num:Num, gap:[tv:_TV | G], sem:NP]) -->
  np([coord:no, num:Num, gap:G, sem:NP]).
np([coord:no, num:Num, gap:[useTVGap, tv:TV | G], sem:NP]) -->
  np([coord:_, num:Num, gap:G, sem:NP1]),
  { combine(np:NP, [np:NP1, tv:TV])}.

np([coord:CoordType, num:CoordNum, gap:G, sem:NP, vType:Type]) -->
  { npCoordNum(CoordType, CoordNum) },
  coordPrefix([type:CoordType]),
  { Coord1 = no ; Coord1 = np},
  np([coord:Coord1, num:sg, gap:G, sem:NP1, vType:Type]),
  noCoord([type:CoordType, sem:C]),
  np([coord:CoordType, num:_, gap:G, sem:NP2, vType:Type]),
  { combine(np:NP, [np:NP1, coord:C, np:NP2]) }.
np([coord:CoordType, num:CoordNum, gap:G, sem:NP, vType:Type]) -->
  { npCoordNum(CoordType, CoordNum) },
  coordPrefix([type:CoordType]),
  { Coord1 = no ; Coord1 = np},
  np([coord:Coord1, num:sg, gap:G, sem:NP1, vType:Type]),
  coord([type:CoordType, sem:C]),
  { member(Coord, [CoordType, no, np]) },
  np([coord:Coord, num:_, gap:G, sem:NP2, vType:Type]),
  { combine(np:NP, [np:NP1, coord:C, np:NP2]) }.
npCoordNum(conj, pl).
npCoordNum(disj, sg).
npCoordNum(neg, sg).
\end{dcg}

\section{Verbale constituent}

\begin{dcg}{De grammaticale regels voor een verbale constituent}{dcg:vp}

vp([coord:no, inf:I, num:Num, gap:G, sem:Sem]) -->
  tv([inf:I, num:Num, gap:Prep-Post, sem:TV]),
  optional(Prep, PrepPresent),
  np([coord:NPCoord, num:_, gap:[tv:TV | G], sem:NP]),
  optional(Post, PostPresent),
  { PrepPresent = present -> true ; NPCoord == comp },
  { PostPresent = present -> true ; NPCoord == comp },
  { Sem = app(TV, NP) }.

vp([coord:no, inf:I, num:Num, gap:[], sem:Sem]) -->
  np([coord:_, num:_, gap:[], sem:NP]),
  tv([inf:I, num:Num, gap:_-[], sem:TV]),
  { Sem = lam(N1, app(app(TV, N1), NP))}.

vp([coord:no, inf:Inf, num:Num, gap:[], sem:Sem]) -->
  av([inf:Inf, num:Num, sem:AV]),
  { Inf2 = inf ; Inf2 = part },
  vp([coord:_, inf:Inf2, num:_, gap:[], sem:VP]),
  { Sem = app(AV, VP) }.

vp([coord:no, inf:Inf, num:Num, gap:[], sem:Sem]) -->
  cop([type:np, inf:Inf, num:Num, sem:Cop]),
  np([coord:NPCoord, num:_, gap:[], sem:NP]),
  { NPCoord \= comp },
  { Sem = app(Cop, NP) }.

vp([coord:no, inf:Inf, num:Num, gap:[], sem:Sem]) -->
  cop([type:pp, inf:Inf, num:Num, sem:Cop]),
  pp([sem:PP]),
  { Sem = app(Cop, PP) }.

vp([coord:yes, inf:Inf, num:Num, gap:[], sem:Sem]) -->
  vp([coord:no, inf:Inf, num:Num, gap:[], sem:VP1]),
  coord([type:_, sem:Coord]),
  vp([coord:_, inf:Inf, num:Num, gap:[], sem:VP2]),
  { CoordinatedVP = app(app(Coord, VP1), VP2) },
  { Sem = lam(N, app(N, lam(X, app(CoordinatedVP, lam(P, app(P, X)))))) }.

vp([coord:no, inf:Inf, num:Num, gap:[], sem:Sem]) -->
  cop([type:np, inf:Inf, num:Num, sem:_]),
  numberOrAll(),
  [different],
  n([coord:_, num:Num, sem:_N]),
  { Sem = lam(N, app(N, lam(X, drs([], [alldifferent(X)])))) }.


optional([], _) -->
  [].
optional(X, present) -->
  { X \= [] },
  X.
optional(X, absent) -->
  { X \= [] },
  [].

numberOrAll() -->
  number([sem:_]).
numberOrAll() -->
  [all].
\end{dcg}

\section{Zin}
