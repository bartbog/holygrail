% !TeX root = ./main.tex


\begin{itemize}
  \item Davies'MaxSAT version ? (takes a lot of space on paper)
  \item OMUS v1
  \item OMUS v2
\end{itemize}
\emilio{
  In this section, we first introduce the notion of OMUS and extend the smallest MUS approach \cite{ignatiev2015smallest} to compute optimal MUS with respect to an objective function. 
}
We further improve the efficiency of the OMUS algorithm using ideas from the improved \textsc{MaxHS} algorithm \cite{davies2013postponing}.

\begin{definition}
  A MUS of $\m{F}$ with an optimal value w.r.t an \emph{objective function $f$} is called an \textbf{Optimal Minimal Unsatisfiable Subset} (OMUS).
\end{definition}

Similar to computing the \texttt{SMUS}, the OMUS requires computing \textit{minimum} hitting sets with respect to $f$:

\begin{definition}
  Let $\m{K}$ be a collection of sets, $HS(\m{K})$ the set of all hitting sets on $\m{K}$ and let $f$ be an monotonic objective function.
  A hitting set $ h \in HS(\m{K})$ is said to be an \textbf{optimal} hitting set if $\forall$ $h' \in HS(\m{K})$ we have that $f(h) \leq f(h')$ with respect to f. %\cite{davies2011solving}.
\end{definition}

While any objective function is applicable for OMUSes, the set of possible objective functions is constrained to \emph{monotonic} functions to guarantee that the algorithm \ref{alg:omus} presented below finds the OMUS.

\begin{definition}
  Given a CNF Formula $\m{F}$, let $f : 2^{\m{F}} \rightarrow \mathbb{R}$ be a mapping of a sets of clauses to real numbers. f is said to be a \emph{monotonic} objective function if for any subsets $\m{A}$, $\m{B}$ of $\m{F}$ if $\m{A} \subseteq \m{B}$ then $f(\m{A}) \leq f(\m{B})$.
\end{definition}

The OMUS is then computed using the following observation:

\begin{proposition}\label{prop:optimal-hitting-set}
  A set $\m{U} \subseteq \m{F}$ is an OMUS of $\m{F}$ iff $\m{U}$ is an optimal hitting set of MCSes($\m{F}$).
\end{proposition}

Lemma \ref{lemma:K} specifies that, in practice, it is not required to enumerate all MCSes of $\m{F}$.
The algorithm only requires finding an optimal hitting set on MCSes($\m{F}$) tat is unsatisfiable.

\begin{lemma}\label{lemma:K}
  Let $\m{K} \subseteq$ MCSes($\m{F}$). Then a subset $\m{U}$ of $\m{F}$ is an OMUS if $\m{U}$ is a \textbf{optimal} hitting set on $\m{K}$ and $\m{U}$ is \textbf{unsatisfiable}.
\end{lemma}


\begin{algorithm}[ht]
  \DontPrintSemicolon
  $\m{K} \gets \emptyset$  \label{omus-line1} \;
  \While{true}{
    $hs \gets$ \texttt{FindMinCostHittingSet}($\m{K}, f$) \label{omus-hs} \;%\tcp*{\small Find \textbf{optimal} solution}
    % \tcp{\small set with all unique clauses from hitting set}
    (sat?, $\kappa$) $\gets$ \texttt{SatSolver}($hs$)\;
    % \tcp{If SAT, $\kappa$ contains the satisfying truth assignment}
    % \tcp{IF UNSAT, $hs$ is the OMUS }
    \If{ not sat?}{
      \Return{$(hs,  \m{K})$} \;
    }
    $MSS \gets  \texttt{Grow}($hs$) $\;
    $\m{K} \gets \m{K} \cup \{  \m{F}$ $\setminus MSS\}$ \;
  }
  \caption{\textsc{OMUS($\m{F}, \ f$)}}
  \label{alg:omus}
\end{algorithm}


% The \texttt{OMUS} algorithm repeatedly computes the optimal hitting set $hs$ (line \ref{omus-hs}) on the already found $\m{K}$, the MCSes of $\m{F}$. If the $hs$ is satisfiable, $hs$ is grown grown to 
% The algorithm terminates and $hs$ is guaranteed to be the OMUS based on lemma \ref{lemma:K}. 

From proposition \ref{prop:MCS-MUS-hittingset}, if $hs$ is unsatisfiable, that means it hits all MCSes($\m{F}$). 
Furthermore, $hs$ is also a cost optimal hitting set on $\m{K}$. It means that if we add any MCS to $\m{K}$, the cost of other hitting sets will either increase in cost or remain the same.

% Lemma \ref{lemma:K} also 

Note if we assign a weight to all clauses equal to the number of literals it contains, then we reduce the problem of finding an optimal hitting set back to finding the minimum hitting set.
% The algorithm then computes the smallest MUS instead of the OMUS \cite{ignatiev2015smallest}.

% \subsection*{Implementation}

Inspired by the approach of Davies and Bacchus \cite{davies2011solving}, the optimal hitting set problem is formulated as a Linear integer Program and encoded into the MIP solver. 
Contrary to the \texttt{SMUS} algorithm, which uses the \textsc{SAT} solver to compute minimum hitting sets. 

The implementation of the grow procedure can be achieved in different ways.
In fact, we could call a weighted partial \textsc{MaxSAT} solver to find the maximal satisfiable subset of clauses grown from the hitting set.
In practice, we use a greedy approximation strategy to find a sastisfying assignment favoring literals that will satisfy the most clauses of highest weights.
More precisely, we rank the clauses based on the ratio of weight to the number of literals not yet assigned in the clause.




% \begin{algorithm*}
%   \DontPrintSemicolon
%   \SetKwSwitch{Switchy}{Case}{Default}{swtich}{}{case}{otherwhise}{}%
%   \Begin{
%     \tcp{F = unsatisfiable CNF formula; M = Collection of MSSes; $f_{cost}$ = cost function}

%     $\m{K} \gets $ $\emptyset$ \;
%     \tcp{grow mss from input mss}
%     \ForEach(){$\m{MSS} \in \m{M}$}{
%       $\m{MSS}' \gets$ {Grow($\m{F} \cap \m{MSS}$)} \;
%       % $\m{MSS} \gets $  \;
%       $\m{K} \gets \m{K} \cup \{  \m{F} \setminus \m{MSS}'\}$ \;
%     }

%     % $\m{M} \gets \emptyset$ \;
%     mode $\gets$ mode\_greedy \;
%     % \sout{$\m{H} \gets \m{H}_0$} \;
%     \While{true}{
%       % \tcp{Find a series of non-optimal solutions}
%       \While{true \label{alg:omus-nonOPT-nested-start}}{
%         \Switch{$nonOptLevel$}{
%           \Case{mode\_incr}{
%             $hs \gets$ {FindIncrementalHittingSet}($\m{K}$, $\m{C}$, $hs$)\;
%           }
%           \Case{mode\_greedy}{
%             $hs \gets$ {FindGreedyHittingSet}($\m{K}$)\;
%           }
%         }

%         (sat?, $\kappa$) $\gets$ {SatSolver}($hs$)\;
%         \uIf{ not sat?}{
%           \Switch{$nonOptLevel$}{
%             \Case{mode\_incr}{
%               mode $\gets$  mode\_greedy \;
%             }
%             \Case{mode\_greedy}{
%               mode $\gets$  mode\_opt \;
%               \textbf{break} \;
%             }
%           }
%         }
%         \uElse{
%           % \todo{is this really correct to add it to MSS ? }\;
%           $MSS \gets $ {Grow}($hs$) \;
%           $\m{M} \gets \m{M} \cup \{  MSS \}$ \;
%           $\m{K} \gets \m{K} \cup \{  \m{F} \setminus MSS\}$ \;
%           mode $\gets$  mode\_incr \;
%         }
%       }
%       $hs \gets$ {OptimalHittingSet}($\m{K}, f_{cost}$) \;

%       (sat?, $\kappa$) $\gets$ {SatSolver}($hs$)\;

%       \If{ not sat?}{
%         \Return{$hs$,  $\m{M}$}
%       }
%       $MSS \gets $ {Grow}($hs$) \;
%       $\m{M} \gets \m{M} \cup \{  MSS \} $\;
%       $\m{K} \gets \m{K} \cup \{  \m{F} \setminus MSS\}$ \;
%       mode $\gets$ mode\_incr \;
%       \label{alg:omus-nonOPT-nested-end}
%     }
%   }
%   \caption{OMUS-Delayed($\m{F}, \m{M}, f_{cost}$)}
%   \label{alg:omus-nonOPT}
% \end{algorithm*}

