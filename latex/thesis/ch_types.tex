\chapter{Types}
\label{ch:types}

Hoofdstuk~\ref{ch:framework} introduceerde een framework voor semantische analyse. Hoofdstukken~\ref{ch:lexicon} en \ref{ch:grammatica} beschreven hoe we dit framework konden gebruiken voor het vertalen van logigrammen naar logica. Op basis van deze drie hoofdstukken kunnen we nu de zinnen van een logigram omzetten naar zinnen in eerste-orde-logica. Om de computer een logigram automatisch te laten oplossen, is er ook nog nood aan een formeel vocabularium. Om dit te kunnen opstellen voegen we types toe aan het semantische framework.

\paragraph{} We beschrijven eerst het achterliggende idee en hoe we dit kunnen toepassen op logigrammen. Dan bekijken we welke aanpassingen het lexicon en de grammatica moeten ondergaan. Vervolgens leggen we uit welke informatie er nog nodig is om de types af te leiden. Ten slotte bespreken we de ontbrekende stappen van de vertaling van logigrammen naar een logische specificatie (waaronder het formele vocabularium).

\section{Het achterliggende idee}
In natuurlijke taal kan men vele zinnen vormen zonder echte betekenis die wel grammaticaal correct zijn. Bijvoorbeeld de zin ``Het gras drinkt het zingende huis'' houdt weinig steek. Idealiter zouden we zo'n zinnen willen bestempelen als foutief. Gras is namelijk niet iets dat kan drinken en een huis kan ook niet zingen of gedronken worden. We zeggen dat ze niet van het juiste type zijn.

In de bestaande literatuur over gestructureerde natuurlijke talen (CNL's) wordt hier weinig of geen aandacht aan besteed\footnote{In hoofdstuk~\ref{ch:related} was RuleCNL de enige taal die ook gebruik maakt van types}. Deze thesis introduceert types in het framework van Blackburn en Bos \cite{Blackburn2005, Blackburn2006} (zie ook hoofdstuk~\ref{ch:framework}). Verder onderzoek is nodig. 

\paragraph{} Concreet krijgt elke grammaticale categorie een feature \texttt{vType}\footnote{We kiezen voor \texttt{vType} omdat sommige grammaticale categorieën reeds een feature \texttt{type} hebben. De \texttt{v} staat voor vocabularium.}. Ook een aantal lexicale categorieën krijgen deze feature (de meeste open categorieën alsook de voorzetsels).

Het type van een naamwoordgroep komt overeen met het type van de entiteit waarnaar het verwijst. Het type van een verbale constituent is gelijk aan dat van het onderwerp. Het type van een transitief werkwoord bestaat dan weer uit een type-paar. Het eerste voor het type van het onderwerp (en dus de verbale constituent) en het andere voor het type van het lijdende voorwerp. Ook een voorzetsel heeft een paar als waarde voor \texttt{vType}. Het ene komt overeen met dat van het substantief dat getransformeerd wordt en het andere komt overeen met dat van de naamwoordgroep uit de voorzetselconstituent.

\paragraph{} Op basis van types kan men zinnen in natuurlijke taal type-checken. Voor deze thesis gaan we echter nog verder en doen we ook aan type-inferentie. Concreet willen we dus te weten komen dat ``France'' en ``Italy'' van hetzelfde type zijn, zonder per se te weten wat het type juist is. We hoeven dus niet te weten dat het om landen gaat. Wat ons vooral interesseert is het groeperen van de verschillende eigennamen volgens hun domein. We zouden ook in het lexicon elk woord kunnen annoteren met haar type. Het doel van deze thesis is echter om het lexicon zo eenvoudig mogelijk te houden. 

In sommige toepassingen van het KBS-paradigma, zoals requirements engineering, wordt er eerst een domein opgesteld. Dit domein zou dan ook in een lexicon met types gegoten kunnen worden. Daarna kan men een specificatie schrijven die ook juist getypeerd is. M.a.w. men zou niet over het stuur van een auto kunnen spreken als auto's in het domeinmodel niet over een stuur beschikken. Zo kan men fouten in de specificatie of het domein opsporen. Verder onderzoek over de haalbaarheid en nuttigheid hiervan is nodig.

\section{Types voor logigrammen}
\paragraph{} Voor type-inferentie in logigrammen maken we één aanname: elk woord uit het lexicon heeft binnen één logigram exact één type. Later zal blijken dat hier niet altijd aan voldaan is (zie hoofdstuk~\ref{ch:evaluatie}). Het type-systeem zelf is vrij simpel: het bestaat uit een aantal basistypes en één afgeleid type: een type-paar. Een type-paar moet altijd twee basistypes als argument hebben. Er is geen type-hiërarchie. Men kan dus niet uitdrukken dat mensen en dieren allebei levende wezens zijn. Type-checking is volledig gebaseerd op unificatie. Een basistype matcht met een andere basistype als ze gelijk zijn. Een type-paar matcht met een andere type-paar als beide argumenten matchen met die van het andere paar. We onderscheiden wel twee soorten basistypes: een basistype kan ofwel numeriek zijn ofwel niet. 


\paragraph{} Met een getypeerde natuurlijke taal kunnen we ook vertalen naar een getypeerde formele taal. Daarvoor breiden we DRS-structuren uit met types: elke entiteit is van een bepaald type. Vanaf nu vertalen we ook altijd naar eerste-orde-logica met types. De vertaling van een getypeerde DRS naar getypeerde eerste-orde logica is analoog met de vertaling van DRS naar eerste-orde-logica. De types worden vertaald zoals men verwacht:

\[
  \left(\ \drs{x_1[t_1], \ldots, x_n[t_n]}{
      \gamma_1 \\
      \ldots \\
      \gamma_m
    }\ \right)^{fo} = \exists x_{1}[t_1] \ldots \exists x_n [t_n]\left((\gamma_{1})^{fo} \land \ldots \land (\gamma_m)^{fo}\right)
\]

\[\left(\ \drs{x_1[t_1], ..., x_n[t_n]}{\gamma_1 \\ ... \\ \gamma_m} \Rightarrow B\right)^{fo} =  \forall x_1[t_1]\ldots \forall x_n[t_n]\Bigg(\Big((\gamma_1)^{fo} \land ... \land (\gamma_m)^{fo}\Big) \Rightarrow \Big(B\Big)^{fo} \Bigg)\]

\section{Aanpassingen}
\paragraph{} We voegen geen type informatie toe aan het lexicon. We houden voor elk woord wel bij met welk type het is gebruikt. De vertaling van een zelfstandig naamwoord is nu veel simpeler: $\sem{noun} = \lambdaf{P}{\drs{}{}}$ Er is geen restrictie meer vanuit het zelfstandig naamwoord, deze restrictie zit volledig in het type van de entiteit. Een determinator heeft als vertaling $$\sem{det} = \lambdaf{R}{\lambdaf{S}{\left( \drs{x[\textit{Type}]}{} \oplus \app{R}{x} \oplus \app{S}{x} \right)}}$$ Hierbij komt \textit{Type} overeen met de waarde van de feature \texttt{vType}. Via unificatie krijgt de entiteit het type van het zelfstandige naamwoord mee.

\paragraph{} Ook bij een comparatief en een onbepaald woord is er een introductie van een nieuwe variabele. Bij een comparatief gebeurt dit gelijkaardig aan de determinator. Het type komt namelijk uit een lexicale feature \texttt{vType} die via de grammatica geünificeerd wordt met andere types. Voor een onbepaald woord is er echter iets speciaals. Het type komt nu niet rechtstreeks uit de lexicale feature. $$\sem{some} = \lambdaf{P}{\drsMerge{\drs{x[\textit{Type1}]}{x > 0}}{\app{P}{x}}}$$ De \textit{Type1} is een numeriek type waarvan het domein bestaat uit de mogelijk verschillen tussen twee waarden uit het domein van \textit{Type} (de waarde van de feature \texttt{vType}). In theorie volstaat het om te stellen dat $x$ een geheel getal moet zijn i.p.v. van type \textit{Type1}. In de praktijk blijkt het echter nodig om het domein te beperken tot de mogelijke verschillen. De inferentie met onderliggende tool IDP \cite{IDP} eindigt immers niet in het geval van gehele getallen.

\paragraph{} De uitbreiding van de grammatica is vrij voor de hand liggend. Grammatica~\ref{dcg:types} geeft een aantal voorbeelden. De eerste grammaticale regel zegt dat het type van het onderwerp gelijk moet zijn aan dat van de verbale constituent. Het type van een verbale constituent komt dan weer overeen met het eerste type van het type-paar van het transitieve werkwoord. Het tweede type van dat paar komt overeen met het lijdend voorwerp.

% De derde grammaticale regel is minder triviaal. Ze stelt dat bij een vergelijkende naamwoordgroep, het type overeenkomt met het type van de entiteit waarmee vergeleken wordt. Het type van het verschil wordt dan weer doorgegeven aan de comparatief.

\begin{dcg}{Een aantal grammaticale regels met type}{dcg:types}
s([coord:no, sem:Sem]) -->
  np([coord:_, num:Num, gap:[], sem:NP, vType:Type]),
  vp([coord:_, inf:fin, num:Num, gap:[], sem:VP, vType:Type]),
  { Sem = app(VP, NP) }.

vp([coord:no, inf:I, num:Num, gap:G, sem:Sem, vType:TypeSubj]) -->
  tv([inf:I, num:Num, positions:Pre-Post, sem:TV, vType:TypeSubj-TypeObj]),
  Pre,
  np([coord:_, num:_, gap:G, sem:NP, vType:TypeObj]),
  Post,
  { Sem = app(TV, NP) }.
\end{dcg}

\section{Extra informatie}
\paragraph{} We vertalen elke zin apart. De types worden daarna geünificeerd volgens het principe van één type per woord. Met dit principe kunnen we echter niet per se alle eigennamen voldoende groeperen. Het kan zijn dat één domein nog steeds is opgesplitst in meerdere groepen (types). Om de onderliggende axioma's van een logigram correct te kunnen uitdrukken, moeten deze types overeenkomen met de domeinen.

De reden dat de groepering niet compleet hoeft te zijn, heeft te maken met synoniemen. Het programma is namelijk niet op de hoogte van welke woorden synoniemen zijn. In het worst-case scenario komt elk woord maar één keer voor. In dat geval leert het principe ons niets en zijn alle eigennamen volledig gescheiden van elkaar.

Er is dus nood aan extra informatie.

\paragraph{} Deze extra informatie bestaat o.a. uit het aantal domeinen in de logigram. We moeten namelijk weten wanneer we mogen stoppen met unificeren.

Daarnaast stellen we nog een aantal ja-nee-vragen aan de gebruiker. We beperken onszelf opnieuw zo veel mogelijk tot taalkundige informatie. Er zijn 4 soorten vragen: ``Zijn A en B dezelfde relatie (synoniemen)?'', ``Zijn A en B een omgekeerde relatie?'', ``Is A een mogelijk lijdend voorwerp van B?'' en ``Zijn A en B van hetzelfde type?''. De eerste drie soorten vragen zijn puur taalkundig en zouden herschreven kunnen worden in de vorm ``Is ... een geldige zin?''. De laatste soort vraag is eigenlijk het doel van het hele type-systeem, namelijk achterhalen of twee domeinelementen van hetzelfde type zijn. Indien een bepaald domein in de logigram altijd wordt voorgesteld door een naamwoordgroep met een onbekende relatie (zie sectie~\ref{sec:npMissingRelation}) dan heeft men geen informatie over het type van deze domeinelementen en geen mogelijke relatie waar deze domeinelementen deel van kunnen maken. Er is dus geen mogelijke taalkundige vraag in dat geval.

Deze vragen worden gesteld totdat er genoeg types geünificeerd zijn, en enkel als er iets uit geleerd kan worden. Als twee werkwoorden bijvoorbeeld al exact hetzelfde type hebben, dan weten we dat het sowieso synoniemen zijn. Er is namelijk maar één bijectie tussen elke twee domeinen in een logigram.

\section{Een formeel vocabularium}
\paragraph{} Op basis van de types kunnen we een aantal inferenties doen. De belangrijkste inferentie is het opstellen van een formeel (getypeerd) vocabularium.

\paragraph{}Er zijn 4 soorten types in het formele vocabularium. Er zijn twee numerieke soorten die vertaald worden naar een subset van de gehele getallen. Er zijn ook twee niet-numerieke soorten die vertaald worden naar constructed types. Als er een substantief is van een bepaald type, dan geeft die een naam aan het type. De resterende types worden gewoon genummerd (\texttt{type1}, \texttt{type2}, ...).

De meest voorkomende soort is een niet-numeriek type met eigennamen van dat type. De eigennamen vormen in dat geval domeinelementen en kunnen vertaald worden naar de constanten van de constructed type. Het is echter ook mogelijk dat er 1 domeinelement ontbreekt. Niet alle domeinelementen hoeven namelijk voor te komen in de zinnen van de logigram. De gebruiker moet dus ook opgeven hoeveel elementen er in elk domein zitten. Het ontbrekende element wordt dan toegevoegd als een extra constante. Bij de oplossing van de logigram kan er dan bijvoorbeeld \texttt{the\_other\_person} komen te staan. Men weet dan over welke persoon het gaat. Er kan immers maar één element missen. Als er twee elementen zouden missen, dan zou men het onderscheid niet kunnen maken tussen de twee elementen. Er is echter altijd een unieke oplossing.

Een niet-numeriek type zonder eigennamen van dat type stelt geen domein voor. Het is een tussenliggend type om twee andere types te verbinden. Bijvoorbeeld ``tour'' in de zin ``John follows the tour with 54 people''. Er zijn twee echte domeinen in deze zin: de personen (met hun naam) en de groottes van een groep. We introduceren een constructed type met evenveel constanten als er domeinelementen zijn. Deze constanten spelen geen rol buiten voor het verbinden van de andere types. We zullen dus ook symmetrie-brekende axioma's moeten opleggen aan zo'n types om tot een unieke oplossing te komen.

Er zijn twee soorten numerieke types: een echt type dat een domein voorstelt en een gelinkt type dat het verschil tussen twee domeinelementen voorstelt. Het tweede type is enkel nodig indien er in de logigram een vergelijking voorkomt met een onbepaald woord. Zoals eerder aangehaald is dit type de subset van gehele getallen die een verschil zijn tussen twee domeinelementen van het echte type. In tegenstelling tot voor een niet-numeriek type kunnen we hier de nodige domeinelementen niet afleiden uit de tekst. We hebben alle getallen nodig. Het volstaat niet om alle getallen buiten één te kennen. Bovendien kan het zelfs zijn dat er meer dan één getal ontbreekt. Voor numerieke types vragen we dus de domeinelementen aan de gebruiker.

\paragraph{} De predicaten uit het formeel vocabularium worden allemaal geïnduceerd door voorzetsels en transitieve werkwoorden. De types van het predicaat komen overeen met het type-paar van de woorden. 

Via types is het bovendien mogelijk om de ontbrekende predicaten uit sectie~\ref{sec:npMissingRelation} (Een naamwoordgroep met onbekende relatie) te achterhalen. We weten het type van $x$ en $y$ en dus het domein. Bovendien is er binnen logigrammen altijd maar één functie tussen twee domeinen, namelijk de bijectie die we zoeken. We zoeken dus een werkwoord of voorzetsel met het juiste type-paar. Indien er (minstens) één bestaat kunnen we het predicaat dat overeenkomt met dat woord kiezen. Dit verhoogt de leesbaarheid van de formele vertaling. Het kan echter zijn dat er zo geen woord bestaat. In dat geval introduceren we een nieuw predicaat met de juiste types.

We gebruiken voor alle predicaten de predicaat-syntax (en dus niet de functionele syntax). De theorie bevat de nodige axioma's om deze predicaten te beperken tot bijecties.

% \section{Het juiste predicaat} */
% \paragraph{} Een tweede inferentie bestaat eruit om ontbrekende predicaten uit sectie~\ref{sec:npMissingRelation} (Een naamwoordgroep met onbekende relatie) te achterhalen. Dit zal gebeuren voor we vertalen naar het formele vocabularium. */

% We weten het type van $x$ en $y$ en dus het domein. Bovendien is er binnen logigrammen altijd maar één functie tussen twee domeinen, namelijk de bijectie die we zoeken. We zoeken dus het werkwoord of voorzetsel met het juiste type-paar. Indien er één bestaat kunnen we het predicaat dat overeenkomt met dat woord kiezen. Dit verhoogt de leesbaarheid van de formele vertaling. Het kan echter zijn dat er zo geen woord bestaat. In dat geval introduceren we een nieuw predicaat met de juiste types. */

\section{Een correcte theorie}
Naast de zinnen van een logigrammen zijn er ook altijd een aantal beperkingen die eigen zijn aan een logigram en die niet expliciet vermeld worden. Daarom bevat een correcte theorie voor logigrammen nog extra axioma's. Er zijn 5 soorten axioma's. Een deel hiervan is gebaseerd op de types van de predicaten.

\begin{itemize}
  \item Elk predicaat is een bijectie. Voor elk predicaat zijn er dus twee extra zinnen in de vorm van $\forall x \cdot \exists y \cdot pred(x, y)$ en $\forall y \cdot \exists x \cdot pred(x, y)$ die dit uitdrukken.
  \item Er zijn 3 soorten axioma's die uitdrukken dat er equivalentieklassen bestaan van verschillende domeinelementen die samenhoren. Elke klasse bevat één domeinelement van elk domein. Twee elementen zijn equivalent als ze gelinkt zijn via een predicaat of als ze aan elkaar gelijk zijn (op die manier is aan reflexiviteit voldaan).
    \begin{itemize}
      \item \textbf{Synonymie} Er is exact één bijectie tussen twee domeinen. Twee predicaten met dezelfde types zijn dus altijd synoniemen. $\forall x \forall y \cdot pred_1(x, y) \Leftrightarrow pred_2(x, y)$. M.a.w. er is maar één equivalentierelatie.
      \item \textbf{Symmetrie} Predicaten met een omgekeerde signatuur stellen elkaars inverse voor $\forall x \forall y \cdot pred_1(x, y) \Leftrightarrow pred_2(y, x)$
      \item \textbf{Transitiviteit} Ten slotte zijn er nog axioma's om de verschillende bijecties te linken. Deze axioma's zorgen voor de transitiviteit van de equivalentierelatie. Bijvoorbeeld de predicaten $pred_1(t_x, t_y)$, $pred_2(t_x, t_z)$ en $pred_1(t_z, t_y)$ introduceren het axioma $\forall x \forall y \cdot pred_1(x, y) \Leftrightarrow \exists z \cdot pred_2(x, z) \land pred_3(z, y)$
    \end{itemize}
  \item Niet-numerieke types zonder eigennamen introduceren een aantal nieuwe constanten. Deze constanten zijn inwisselbaar. Om een unieke oplossing te bekomen introduceren we een aantal axioma's die de constanten van zo'n type linken aan de domeinelementen van een domein naar keuze. Bijvoorbeeld $pred_1(NewConstant1, John) \land pred_1(NewConstant2, Mary) \land pred_1(NewConstant3, Charles)$.
\end{itemize}

\section{Conclusie en verder onderzoek}
Met behulp van types is het mogelijk om natuurlijke taal te type-checken. Zo kan men betekenisloze zinnen uitsluiten. Bovendien kan men met behulp van type-inferentie een deel van de wereldkennis afleiden. Zo kunnen we weten dat ``France'' en ``Italy'' gelijkaardige concepten uitdrukken, zonder te weten wat die concepten zijn. Dit is zeker geen nieuw resultaat (Mikolov et al. \cite{Mikolov2013} behaalden straffere resultaten via neurale netwerken). Het is wel een nieuwe manier om tot die resultaten te komen. Er zijn minder zinnen voor nodig, maar ze moet wel een bepaalde grammatica volgen.

\paragraph{} In de bestaande literatuur over CNL's is er meestal geen of een beperkte ondersteuning voor types. De resultaten van deze thesis suggereren echter dat onderzoek hiernaar zeker de moeite waard kan zijn.

Enkel vragen die naar boven komen is of men via type-checken van natuurlijke taal, het aantal fouten in specificaties kan verlagen. Staat het toe om een betere suggestietool te maken die niet alleen rekening houdt met de grammatica maar ook met informatie omtrent types? De types kunnen namelijk het aantal suggesties beperken om zo de kwaliteit van de tool te verbeteren.

In deze thesis werd er gebruik gemaakt van een zeer simpel type-systeem. Ook een onderzoek naar een moeilijker systeem, bijvoorbeeld met een hiërarchie van types, lijkt nodig. Bovendien is de vraag of de techniek ook toepasbaar is op andere problemen dan logigrammen.
