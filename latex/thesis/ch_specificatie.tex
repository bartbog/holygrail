\chapter{Een volledige specificatie}
\label{ch:specificatie}

Hoofdstuk~\ref{ch:framework} introduceerde een framework voor semantische analyse. Hoofdstukken~\ref{ch:lexicon}~en~\ref{ch:grammatica} beschreven hoe we dit framework konden gebruiken voor het vertalen van logigrammen naar logica. Hoofdstuk~\ref{ch:types} voegde types toe aan dit framework. Op basis van deze vier hoofdstukken kunnen we nu de zinnen van een logigram omzetten naar zinnen in eerste-orde-logica met types.

In dit hoofdstuk beschrijven we de ontbrekende delen die nodig zijn om een volledige specificatie op te stellen van een logigram. Voor deze specificatie ontbreekt nog een formeel vocabularium en een aantal axioma's die inherent zijn aan logigrammen. Hierbij zullen we ook gebruik maken van type-informatie.

\section{Een formeel vocabularium}
\label{sec:vocabularium}
\paragraph{} Nadat we de types hebben afgeleid kunnen we een formeel vocabularium opstellen dat ook getypeerd is.

\paragraph{}Er zijn 4 soorten types in het formele vocabularium voor een logigram. Er zijn twee numerieke soorten die vertaald worden naar een subset van de gehele getallen. Er zijn ook twee niet-numerieke soorten die vertaald worden naar constructed types. Constructed types zijn types die bestaat uit een set van constanten met twee extra axioma's ingebouwd, namelijk het Domain Closure Axioma en het Unique Names Axioma. Onder het Domain Closure Axiom verstaan we dat de set van constanten de enige mogelijke elementen zijn van dat type. Het Unique Names Axioma drukt dan weer uit dat alle constanten verschillend zijn van elkaar.

Als er een substantief is van een bepaald type, dan geeft die een naam aan het type. De resterende types worden gewoon genummerd (\texttt{type1}, \texttt{type2}, ...).

\paragraph{} De meest voorkomende soort is een niet-numeriek type dat een domein van een logigram voorstelt. In dat geval zijn er eigennamen van dat type. De eigennamen vormen de domeinelementen en kunnen vertaald worden naar de constanten van de constructed type. Het is echter ook mogelijk dat er 1 domeinelement ontbreekt. Niet alle domeinelementen hoeven namelijk voor te komen in de zinnen van een logigram. De bekendste logigram is genoemd naar zo'n ontbrekend element. \textit{De Zebrapuzzel} is een logigram waar de lezer gevraagd wordt welke persoon een zebra heeft. De zebra komt voor de rest niet voor in de logigram.

De gebruiker moet daarom opgeven hoeveel elementen er in elk domein zitten. Het ontbrekende element wordt dan toegevoegd als een extra constante. Omwille van het Domain Closure Axioma mag deze constante zeker niet ontbreken. Bij de oplossing van het logigram kan er dan bijvoorbeeld \texttt{the\_other\_person} komen te staan. Men weet dan over welke persoon het gaat. Er kan immers maar één element ontbreken. Als er twee elementen zouden ontbreken, dan zou men het onderscheid niet kunnen maken tussen de twee elementen. Er is echter altijd een unieke oplossing.

\paragraph{} Daarnaast is er een niet-numeriek type dat geen domein van een logigram voorstelt. In dat geval zijn er geen eigennamen van dat type. Het is een tussenliggend type om twee andere types te verbinden. Bijvoorbeeld ``tour'' in de zin ``John follows the tour with 54 people''. Er zijn twee echte domeinen in deze zin: de personen (met hun naam) en de groottes van een groep. We introduceren een constructed type met evenveel constanten als er domeinelementen zijn. Deze constanten spelen geen rol buiten voor het verbinden van de andere types. We zullen dus ook symmetrie-brekende axioma's moeten opleggen aan zo'n types om tot een unieke oplossing te komen.

\paragraph{} Er zijn ook twee soorten numerieke types. De eerste stelt opnieuw een domein voor van een logigram. In tegenstelling tot voor een niet-numeriek type kunnen we hier de nodige domeinelementen niet afleiden uit de tekst. We hebben alle getallen nodig. Het volstaat niet om alle getallen buiten één te kennen. Bovendien kan het zelfs zijn dat er meer dan één getal ontbreekt. Voor numerieke types vragen we dus de domeinelementen aan de gebruiker.

Het is ook mogelijk dat zo'n numeriek type nog een afgeleid type heeft. Dit gaat dan om een \textit{TypeDiff} uit sectie~\ref{sec:aanpassingen}. Het domein van het afgeleide type kan automatisch berekend worden uit het domein van het type dat een domein voorstelt.
% \paragraph{} Er zijn twee soorten numerieke types: een echt type dat een domein voorstelt en een gelinkt type dat het verschil tussen twee domeinelementen voorstelt. Het tweede type is enkel nodig indien er in het logigram een vergelijking voorkomt met een onbepaald woord. Zoals eerder aangehaald is dit type de subset van gehele getallen die een verschil zijn tussen twee domeinelementen van het echte type. In tegenstelling tot voor een niet-numeriek type kunnen we hier de nodige domeinelementen niet afleiden uit de tekst. We hebben alle getallen nodig. Het volstaat niet om alle getallen buiten één te kennen. Bovendien kan het zelfs zijn dat er meer dan één getal ontbreekt. Voor numerieke types vragen we dus de domeinelementen aan de gebruiker. */

\paragraph{} De predicaten uit het formeel vocabularium worden allemaal geïnduceerd door voorzetsels en transitieve werkwoorden. De types van het predicaat worden bepaald door het type van het woord dat het induceerde. ``lives in'' is bijvoorbeeld een werkwoord dat een mens als onderwerp neemt en een land als lijdend voorwerp. \texttt{lives\_in} zal daarom een predicaat zijn met een eerste argument van type \texttt{human} en tweede argument van type \texttt{country}.

Via types is het bovendien mogelijk om de ontbrekende predicaten uit sectie~\ref{sec:npMissingRelation} (Een naamwoordgroep met onbekende relatie) te achterhalen. We weten het type van $x$ en $y$ en dus het domein. Bovendien is er binnen logigrammen altijd maar één functie tussen twee domeinen, namelijk de bijectie die we zoeken. We zoeken dus een werkwoord of voorzetsel met het juiste type-paar. Neem bijvoorbeeld ``the 2008 graduate...''. Aangezien ``2008'' een jaartal is, ``graduate'' een persoon en ``graduated in'' een werkwoord tussen een persoon en een jaartal kan de naamwoordgroep herschreven worden als ``the graduate who graduated in 2008, ...''.  Indien er (minstens) één bestaat kunnen we het predicaat dat overeenkomt met dat woord kiezen. Dit verhoogt de leesbaarheid van de formele vertaling. Het kan echter zijn dat er zo geen woord bestaat. In dat geval introduceren we een nieuw predicaat met de juiste types.

We gebruiken voor alle predicaten de predicaat-syntax (en dus niet de functionele syntax). De theorie bevat de nodige axioma's om deze predicaten te beperken tot bijecties.

% \section{Het juiste predicaat} */
% \paragraph{} Een tweede inferentie bestaat eruit om ontbrekende predicaten uit sectie~\ref{sec:npMissingRelation} (Een naamwoordgroep met onbekende relatie) te achterhalen. Dit zal gebeuren voor we vertalen naar het formele vocabularium. */

% We weten het type van $x$ en $y$ en dus het domein. Bovendien is er binnen logigrammen altijd maar één functie tussen twee domeinen, namelijk de bijectie die we zoeken. We zoeken dus het werkwoord of voorzetsel met het juiste type-paar. Indien er één bestaat kunnen we het predicaat dat overeenkomt met dat woord kiezen. Dit verhoogt de leesbaarheid van de formele vertaling. Het kan echter zijn dat er zo geen woord bestaat. In dat geval introduceren we een nieuw predicaat met de juiste types. */

\section{De ontbrekende axioma's}
Naast de zinnen van een logigrammen zijn er ook altijd een aantal beperkingen die eigen zijn aan een logigram en die niet expliciet vermeld worden. Daarom bevat een correcte theorie voor logigrammen nog extra axioma's. Er zijn 5 soorten axioma's. Een deel hiervan is gebaseerd op de types van de predicaten.

\begin{itemize}
  \item Elk predicaat is een bijectie. Voor elk predicaat is er dus een extra zin in de vorm van $\forall x \cdot \exists y \cdot pred(x, y) \land \forall y \cdot \exists x \cdot pred(x, y)$ die dit uitdrukken. Bijvoorbeeld voor \texttt{lives\_in}: $\forall x \cdot \exists y \cdot lives\_in(x, y) \land \forall y \cdot \exists x \cdot lives\_in(x, y).$
  \item Er zijn 3 soorten axioma's die uitdrukken dat er equivalentieklassen bestaan van verschillende domeinelementen die samenhoren. Elke klasse bevat één domeinelement van elk domein. Twee elementen zijn equivalent als ze gelinkt zijn via een predicaat of als ze aan elkaar gelijk zijn (op die manier is aan reflexiviteit voldaan).
    \begin{itemize}
      \item \textbf{Synonymie} Er is exact één bijectie tussen twee domeinen. Twee predicaten met dezelfde types zijn dus altijd synoniemen. $\forall x \forall y \cdot pred_1(x, y) \Leftrightarrow pred_2(x, y)$. M.a.w. er is maar één equivalentierelatie. Bijvoorbeeld voor \texttt{from(person, country)} and \texttt{lives\_in(person, country)}: $\forall x \forall y \cdot lives\_in(x, y) \Leftrightarrow from(x, y)$
      \item \textbf{Symmetrie} Predicaten met een omgekeerde signatuur stellen elkaars inverse voor $\forall x \forall y \cdot pred_1(x, y) \Leftrightarrow pred_2(y, x)$. Bijvoorbeeld \texttt{gave(student, presentation)} en \texttt{given\_by(presentation, student)}: $\forall x \forall y \cdot gave(x, y) \Leftrightarrow given\_by(y, x)$
      \item \textbf{Transitiviteit} Ten slotte zijn er nog axioma's om de verschillende bijecties te linken. Deze axioma's zorgen voor de transitiviteit van de equivalentierelatie. Bijvoorbeeld de predicaten $pred_1(t_x, t_y)$, $pred_2(t_x, t_z)$ en $pred_3(t_z, t_y)$ introduceren het axioma $\forall x \forall y \cdot pred_1(x, y) \Leftrightarrow \exists z \cdot pred_2(x, z) \land pred_3(z, y)$. Bijvoorbeeld voor \texttt{spoke\_for(student, time)}, \texttt{gave(student, presentation)} en \texttt{lasted\_for(presentation, time)}: $\forall x \forall y \cdot spoke\_for(x, y) \Leftrightarrow \exists z \cdot gave(x, z) \land lasted\_for(z, y).$
    \end{itemize}
  \item Niet-numerieke types die geen domein voorstellen introduceren een aantal nieuwe constanten. Deze constanten zijn inwisselbaar. Om een unieke oplossing te bekomen introduceren we een aantal axioma's die de constanten van zo'n type linken aan de domeinelementen van een domein naar keuze. Bijvoorbeeld $pred_1(NewConstant1, John) \land pred_1(NewConstant2, Mary) \land pred_1(NewConstant3, Charles)$.
\end{itemize}

\section{Conclusie en verder onderzoek}
Met behulp van types is het mogelijk om natuurlijke taal te type-checken. Zo kan men betekenisloze zinnen uitsluiten. Bovendien kan men met behulp van type-inferentie een deel van de wereldkennis afleiden. Zo kunnen we weten dat ``France'' en ``Italy'' gelijkaardige concepten uitdrukken, zonder te weten wat die concepten zijn. Dit is zeker geen nieuw resultaat (Mikolov et al. \cite{Mikolov2013} behaalden straffere resultaten via neurale netwerken). Het is wel een nieuwe manier om tot die resultaten te komen. Er zijn minder zinnen voor nodig, maar ze moet wel een bepaalde grammatica volgen. Bovendien werkt deze methode niet in het geval van naamwoordgroepen met onbekende relaties (sectie~\ref{sec:npMissingRelation}).

\paragraph{} In de bestaande literatuur over CNL's is er meestal geen of een beperkte ondersteuning voor types. De resultaten van deze thesis suggereren echter dat onderzoek hiernaar zeker de moeite waard kan zijn.

Enkel vragen die naar boven komen is of men via type-checken van natuurlijke taal, het aantal fouten in specificaties kan verlagen. Staat het toe om een betere suggestietool te maken die niet alleen rekening houdt met de grammatica maar ook met informatie omtrent types? De types kunnen namelijk het aantal suggesties beperken om zo de kwaliteit van de tool te verbeteren.

In deze thesis werd er gebruik gemaakt van een zeer simpel type-systeem. Ook een onderzoek naar een moeilijker systeem, bijvoorbeeld met een hiërarchie van types, lijkt nodig. Bovendien is de vraag of de techniek ook toepasbaar is op andere problemen dan logigrammen.
