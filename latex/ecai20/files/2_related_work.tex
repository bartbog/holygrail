Our work is inspired by the holy grail challenge at CP2019, which in turn has its roots in earlier work of E. Freuder on inference-based explanations \cite{sqalli1996inference}. In that work, the authors also look at logic grid puzzles and develop a number of problem-specific inference rules that allow solving such puzzles without search. These inference rules are equiped with explanation templates such that each propagation event of an inference rule also has a templated explanation, and hence an explanation of the solution process is obtained. We point out that the more complex inference rules (NCC and GNCC) are in inference rules over hard-coded combinations of (in)equality constraints. In contrast, our proposed method works for any type of constraint and any combination of constraints, and automatically infers a minimal set of facts and constraints that explain an inference step, without using any problem-specific knowledge.

Explanation of constraint satisfaction problems has been studied mostly in the context of overconstrained problems. The goal is to find what constraints conflict with each other. The QuickXplain method \cite{junker2001quickxplain} for example uses a dichotomic approach that recusively partitions the constraints to find a minimal conflict set. This is also known as the Minimum Unsat Subset (MUS) problem or Minimal Unsat Core extraction~\cite{marques2010minimal}. Many algorithm exist for finding a MUS or enumerating all MUS's~\cite{marques2010minimal}. We will use MUS extraction for finding a minimal explanation of an individual inference step.

There is a rich literature on automated and interactive theorem proving, recently focussing on providing proofs that are understandable for humans \cite{Ganesalingam2017} and, e.g.,  on teaching humans how to craft mathematical proofs using interaction with theorem provers \cite{DBLP:conf/icml/YangD19}. 
Our work fits into this line of research since our generated explanations can also be seen as proofs, but in the setting of finite-domain constraint solving.




