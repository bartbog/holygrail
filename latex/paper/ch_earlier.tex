\section{Related work}

Two of the most advanced controlled natural languages that can be used for knowledge representation are Attempto Controlled English (ACE) \cite{Fuchs2008} and Processable English (PENG) \cite{Schwitter2002}. ACE is a general purpose CNL. The language contains a large built-in vocabularium. This has as advantage that the user doesn't have to provide the vocabularium. However, for specifications in small domains, we usually do want to provide the vocabularium to make sure the specification only talks about the modelled domain. PENG asks the user to provide its own content words. Moreover, there is a tool named ECOLE that gives suggestions while writing PENG sentences about which linguistic constructs can follow. These languages show that we can translate English into logic, but the literature about both these CNL's lacks a description of this translation process. Therefor, extending these CNL's is hard.

Another important CNL is RuleCNL \cite{Njonko2014}. It is a CNL that translates (a subset of) English into business rules. It's notable because it is the only CNL we could find that uses types. Interestingly, they don't really describe their type system nor the inferences they support. However figure~6 from \cite{Njonko2014} indicates that they do support type checking of business rules in RuleCNL.

Finally, Baral et al. \cite{Baral2008, Costantini2010, Baral2012, Baral2012a} researched translating natural language into ASP programs. They do this based on $\lambda$-calculus and a Combinatorial Categorial Grammar (CCG). Each word gets one $\lambda$-ASP-expression per CCG category it can represent. The CCG then tells how to combine these expressions via $\lambda$-application. In their last paper \cite{Baral2012a} they explain how to learn both these $\lambda$-ASP-expressions and a probabilistic CCG grammar from a set of logigrams. They used a supervised machine learning method for this goal. Based on these methods they can solve unseen logigrams without adapting these logigrams.

However, the goal of this paper is not to solve (unseen) logigrams without adapting them. The goal is to create a CNL with formal semantics that can be applied to logigrams and can be used as a knowledge representation language for these logigrams. This illustrates that for a small domain, it is possible to have such a language.
